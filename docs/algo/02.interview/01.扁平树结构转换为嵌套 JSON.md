---
title: 扁平树结构转换为嵌套json
date: 2019-07-08 17:45:38
permalink: /pages/bf041e/
categories: 
  - algo
  - interview
tags: 
  - 
---

## 背景

数据库中存有扁平树结构如下：  
| id |pid| label | depth|
|----|---|-------|------|
| 1  | 0 |  1       | 1 |
| 2  | 1 |  1-1     | 2 |
| 3  | 1 |  1-2     | 2 |
| 4  | 2 |  1-1-1   | 3 |
| 5  | 3 |  1-2-1   | 3 |
| 6  | 2 |  1-1-2   | 3 |
| 7  | 2 |  1-1-3   | 3 |
| 8  | 1 |  1-3     | 2 |
| 9  | 4 |  1-1-1-1 | 4 |
| 10 | 7 |  1-1-3-1 | 4 |

需要转转为如下数据结构

``` json
[
  {
    "id": 1,
    "label": "1",
    "depth": 1,
    "children": [
      {
        "id": 2,
        "label": "1-1",
        "depth": 2,
        "children": [
          {
            "id": 4,
            "label": "1-1-1",
            "depth": 3,
            "children": [ { "id": 9, "label": "1-1-1-1", "depth": 4, "children": [] } ]
          },
          { "id": 6, "label": "1-1-2", "depth": 3, "children": [] },
          {
            "id": 7,
            "label": "1-1-3",
            "depth": 3,
            "children": [ { "id": 10, "label": "1-1-3-1", "depth": 4, "children": [] } ]
          }
        ]
      },
      {
        "id": 3,
        "label": "1-2",
        "depth": 2,
        "children": [ { "id": 5, "label": "1-2-1", "depth": 3, "children": [] } ]
      },
      { "id": 8, "label": "1-3", "depth": 2, "children": [] }
    ]
  }
]
```

## 解法

::: details 

``` js
/**
 * @param {[object]} list
 * @return {[object]}
 * 
 * */
const transListToJsonTree = function (list) {
  function Node(node) {
    this.id = node.id
    this.label = node.label
    this.depth = node.depth
    this.pid = node.pid

    this.left = null
    this.right = null
  }

  function BinaryTree() {
    this.root = null
    this.nodes = []
  }
  BinaryTree.prototype.insert = function (node) {
    let curr_node = node
    if (node instanceof Node === false) {
      curr_node = new Node(node)
    }
    if (!this.root && curr_node.depth === 1) {
      this.root = curr_node
      this.nodes.push(curr_node)
      return true
    } else {
      let root = this.nodes[0]
      while (true) {
        if (curr_node.depth > root.depth) {
          if (root.right === null && curr_node.pid === root.id) {
            //插入子节点
            root.right = curr_node
            this.nodes.push(curr_node)

            return true
          } else { 
            if (curr_node.depth - root.depth !== 1) //跨级节点右移
              root = root.right
            else {
              if(curr_node.pid === root.id) //子节点右移
                root = root.right
              else 
                root = root.left
            }
          }
        } else if (curr_node.depth === root.depth) { //同级子节点挂载按顺序挂载在左边
          if (root.left === null) { 
            root.left = curr_node
            this.nodes.push(curr_node)
            return true
          } else {
            root = root.left
          }
        } else {
          console.log('invalid node: ', node)
          return false
        }
      }
    }

  };
  BinaryTree.prototype.getSubNodes = function (node) {
    const ret = []
    right_left_root(node.right)
    return ret

    function right_left_root(node) {
        if (!node)
            return
        right_left_root(node.right)
        right_left_root(node.left)
        ret.push(node)
    }
  };

  BinaryTree.prototype.serialization = function () {
    const root = this.root
    const ret = [{
      id: root.id,
      label: root.label,
      depth: root.depth,
      children: []
    }]
    const map = {}
    right_left_root(root)

    return ret

    function handler(node) {
      let isLeaf = true
      if (node.right && map[node.right.id]) {
        isLeaf = false
        let right_node = map[node.right.id]
        if (node.right.left) {
          map[node.id] = {
            id: node.id,
            label: node.label,
            depth: node.depth,
            children: map['depth' + right_node.depth]
          }
        } else {
          map[node.id] = {
            id: node.id,
            label: node.label,
            depth: node.depth,
            children: [right_node]
          }
        }
      }
      if (node.left && map[node.left.id]) {
        isLeaf = false
        let ret = map['depth' + node.depth]
        const curr_node = map[node.id] ? map[node.id] : {
          id: node.id,
          label: node.label,
          depth: node.depth,
          children: []
        }
        map[node.id] = curr_node
        const left_node = map[node.left.id]
        if (ret) {
          map['depth' + node.depth].unshift(curr_node)
        } else {
          map['depth' + node.depth] = [curr_node, left_node]
        }
      }
      if (isLeaf) {
        map[node.id] = {
          id: node.id,
          label: node.label,
          depth: node.depth,
          children: []
        }
      }
      if (node.depth === 2) {
        ret[0].children.unshift(map[node.id])
      }
    }

    function right_left_root(node) {
      if (!node)
        return
      right_left_root(node.right)
      right_left_root(node.left)
      handler(node)
    }

  }

  const btree = new BinaryTree()

  for (let item of list) {
    btree.insert(item)
  }

  return btree.serialization()
  // return btree
};
```

:::

## 总结

1. 父节点肯定在子节点前面
2. 子节点的depth属性表示了嵌套深度
100. 从而联想到使用二叉树来解决该问题……

一个目录节点下会存在多个叶子节点，因此严格来说其实不属于二叉树的结构。但b+树太复杂，因此把它强行改良成一棵自定义二叉树：

* 左节点为表示同级目录，多个同级节点，均顺序左移
* 右节点为子目录

按照这个定义就满足二叉树结构了。但插入节点的方法需要重写。  
从而把序列化的问题转换为二叉树遍历的问题。  
准确点说，这里需要使用 `后序遍历` ：从右到左再到根节点，先叶子节点再分支节点。

其实如果仅仅是序列化的问题，应该有跟简洁的解法，考虑到后续节点维护，还是用二叉树结构了。

::: details 测试代码
```js
const list = [
    { id: 1,  pid: 0, label: "1",       depth: 1 },
    { id: 2,  pid: 1, label: "1-1",     depth: 2 },
    { id: 3,  pid: 1, label: "1-2",     depth: 2 },
    { id: 4,  pid: 2, label: "1-1-1",   depth: 3 },
    { id: 5,  pid: 3, label: "1-2-1",   depth: 3 },
    { id: 6,  pid: 2, label: "1-1-2",   depth: 3 },
    { id: 7,  pid: 2, label: "1-1-3",   depth: 3 },
    { id: 8,  pid: 1, label: "1-3",     depth: 2 },
    { id: 9,  pid: 4, label: "1-1-1-1", depth: 4 },
    { id: 10, pid: 7, label: "1-1-3-1", depth: 4 },
]
const ret = transListToJsonTree(list)

console.log(JSON.stringify(ret, null, 2))
```
:::
