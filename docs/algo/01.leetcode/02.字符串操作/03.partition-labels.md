---
title: 划分区间
date: 2019-06-22 16:29:06
permalink: /pages/39fbb7/
categories: 
  - leetcode
  - 字符串操作
tags: 
  - 
---
## 题目描述

::: quote Partition Labels
给定一个全英文小字母组成的的字符串s，尽可能的把该字符串划分为多个部分，每个部分中的每个字母只在当前部分出现。  
结果返回一个整数列表，每个数字代表划分后每个部分的字符串长度。

字符串长度为 [1, 500]  
所有的输入字符串组成都是 `a-z` 的小写字符

示例1：

``` 
Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
划分结果为 "ababcbaca", "defegde", "hijhklij".

划分为 "ababcbacadefegde", "hijhklij" 也是符合要求的，但它不算划分成最多部分的答案
```

javascript:
```js
/**
 * @param {string} S
 * @return {number[]}
 */
var partitionLabels = function(S) {
    
};
```

::: right
From [leetcode No.763 Medium](https://leetcode.com/problems/partition-labels/)
:::

## 解法
::: details 
``` js
/**
 * @param {string} s
 * @return {number[]}
 */
var partitionLabels = function (s) {
  const map = {}
  const ret = []
  let max = 0
  for (let i = 0; i < s.length; i++) {
    map[s[i]] = i
  }
  for (let i = 0; i < s.length; i++) {
    const last_index = map[s[i]]
    if (last_index === s.length - 1) {
      ret.push(last_index)
      break;
    }
    if (i == last_index && i >= max) {
      max = i
      ret.push(i)
    } else {
      max = Math.max(last_index, max)
    }
  }
  for (let i = ret.length - 1; i > 0; i--) {
    ret[i] = ret[i] - ret[i - 1]
  }
  ret[0] = ret[0] + 1
  return ret
};
```
:::
## 总结
字符串的题仍旧是找规律，这里即为怎么找临界点。我的思路是：
- 利用哈希的唯一性定位，确定每一个元素最后出现的位置
- 顺序遍历，当**第一次**匹配到当前位置元素即为最后一次出现时，它就是一个临界点
- 后续元素除了需要满足当前位置为最后出现的位置，还需要满足此时的位置要在上一个临界点后面这一条件
- 当最后出现的位置为当前字符串最末尾时，为特殊情况，可以直接结束后续遍历了
- 记录每一个临界元素的index，最后返回题目要求的返回值

照例学习最快的解法，大致思路不变，优化了结果返回的地方，重新修改如下：
::: details 
``` js
/**
 * @param {string} s
 * @return {number[]}
 */
var partitionLabels = function (s) {
  const map = {}
  const ret = []
  for (let i = 0; i < s.length; i++) {
    map[s[i]] = i
  }
  let max = 0
  let anchor = 0
  for (let i = 0; i < s.length; i++) {
    const last_index = map[s[i]]
    if (last_index === s.length - 1) {
      ret.push(last_index - anchor + 1)
      break;
    }
    if (i == last_index && i >= max) {
      ret.push(i - anchor + 1)
      max = i
      anchor = i + 1
    } else {
      max = Math.max(last_index, max)
    }
  }
  return ret
};
```
:::