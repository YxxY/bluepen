---
title: 最短无序连续数组
date: 2020-08-04 20:28:55
permalink: /pages/f36e43/
categories: 
  - leetcode
  - 数组操作
tags: 
  - 
---

## 题目描述

::: quote  Shortest Unsorted Continuous Subarray
给定一个无序数字数组，需要找出一个连续的子数组，满足只要该字数组重新按升序排列，则整个数组满足升序。找到这样的子数组，返回它的长度。
如不存在这样的子数组，返回 0
示例1：
``` 
Input: [2, 6, 4, 8, 10, 9, 15]
Output: 5
Explanation: 只要 [6, 4, 8, 10, 9] 为升序排列，则整个数组转化为升序
```

另：
- 输入数组长度范围为 [1, 10,000].
- 输入数组可以还有重复值，所以升序中会含有相等的情况.
::: right
From [leetcode No.581 Easy](https://leetcode.com/problems/shortest-unsorted-continuous-subarray/)
:::

``` js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findUnsortedSubarray = function(nums) {
    
};
```

## 解法
::: details 
``` js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findUnsortedSubarray = function (nums) {
  const len = nums.length
  let i = 0
  let j = len - 1
  const n = Array.from(nums).sort((a, b)=>a-b)
  while(j > 0){
    if(n[j] === nums[j]){
      j--;
      continue;
    }
    break;
  }
  if(j === 0)
    return 0
  while (i < j) {
    if(n[i] === nums[i]){
      i++;
      continue;
    }
    break;
  }
  return j - i + 1
};
```
:::

## 总结
思路是将数组按升序排序后生成新的数组，然后比较数组两端的元素。  
获取到起始不相等的元素索引 `i` 以及末尾不相等元素索引 `j`，即索引 `i - j `的元素需要重新排序。  
特殊情况是 `i===j===0`, 即数组本身是有序的，返回 0

学习提交的最快解法，思路差不多，找不相等的序列的起始索引和终点索引，但方法不同，没有排序，也没有使用新数组，更加巧妙。  
思路如下：
- 从后向前循环遍历，寻找序列起始位置。
  - **记录出现元素的最小值，如果当前元素即为最小值，说明当前顺序为升序，否则即说明当前位置存在乱序**，将当前位置设置为锚点并继续遍历
  - 循环结束即可获取到最左边的乱序起点
  - 如遍历结束仍未设置锚点，则说明数组一致保持为升序
- 同理，从前到后循环遍历，寻找序列终点位置
  - 记录出现元素的最大值，如果当前元素不为最大值，则设置为当前元素索引为终点位置锚点并继续遍历
  - 如遍历结束后，仍未设置终点锚点，即说明最后一个元素为值最大的元素

::: details 
``` js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findUnsortedSubarray = function (nums) {
  let start, min = nums[nums.length - 1];
  for (let i = nums.length - 2; i >= 0; i--) {
    min = Math.min(min, nums[i])
    if (nums[i] != min) {
      start = i
    }
  }
  if (start === undefined)
      return 0
  let end, max = nums[0];
  for (let i = 1; i < nums.length; i++) {
    max = Math.max(max, nums[i])
    if (nums[i] != max) {
      end = i
    }
  }
  return end - start + 1
};
```
:::
